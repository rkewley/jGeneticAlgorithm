package jGeneticAlgorithm;

/**
 * Title:        JGeneticAlgorithm
 * Description:  A Java implementation of genetic algorithms
 * Copyright:    Copyright (c) 2002
 * @version 1.0
 */

import java.util.Vector;
import java.util.Collections;
import cern.jet.random.engine.RandomEngine;

/**
 * The ObjectGenome is the most basic Genome class used in the jGeneticAlgorithm
 * package.  All ObjectGenomes in a GA will have chromosomes of the same length.
 * Each location along the chromosome of the ObjectGenome contains
 * a randomly generate AlleleValue Object.  Depending upon the application, this
 * object can be a bit, an integer, a real number, or a much more complex object
 * representing whatever the modeler desires in the phenotype.
 */
public  class ObjectGenome extends Genome {
  /**
  * An linear array of the genome values.
  */
  AlleleValue[] alleleValues;

  /**
  * An array of allele sets for the genome.  Each allele set returns one of
  * a set of possible values for the corresponding position in alleleValues[].
  * alleleSets[] and alleleValues[] must hav the same length.
  */
  AlleleSet[] alleleSets;

  /**
   * The number of crossover points for the genome.  Default = 2.
   */
  int crossoverPoints = 2;

  /**
   * Constructor
   * @param aSets The allele set array for this genome
   * @param engine A random number generator from the cern.jet.random.engine
   * library.
   */
  public ObjectGenome(AlleleSet[] aSets, RandomEngine engine) {
    super(engine);
    alleleSets = aSets;
    alleleValues = new AlleleValue[alleleSets.length];
  }

  /**
   * Returns the array of AlleleValues, the chromosome for this Genome.
   */
  public AlleleValue[] getAlleleValues() {
    return alleleValues;
  }

  /**
   * This allows the AlleleValues for this Genome to be externally set.
   * @param aValues An array of AlleleValues which becomes this Genome's
   * chromosome.
   */
  public void setAlleleValues(AlleleValue[] aValues) throws GAException {
    if (aValues.length != alleleSets.length) {
      throw new GAException(
        "The allele value array must be the same length as the allele set array.");
    }
    alleleValues = aValues;
  }

  /**
   * Set the number of crossover points for the genome.  Default = 2.
   * @param n The number of crossover points must be a positive integer.
   */
  public void setCrossoverPoints(int n) throws GAException {
    if (n <= 0) {
      throw new GAException(
        "The number of crossover points must be a positive integer.");
    }
    crossoverPoints = n;
  }

  /**
   * Returns the number of crossover points for the genome.
   */
  public int getCrossoverPoints() {
    return crossoverPoints;
  }

  /**
   * Randomly initializes each AlleleValue on the Genome's chromosome using
   * the appropriate AlleleSet in the alleleSets[] array.
   */
  public void initialize () {
    int i, s;

    this.setIsEvaluated(false);
    s = alleleSets.length;
    for (i = 0; i < s; i++) {
      alleleValues[i] = alleleSets[i].getRandomValue();
    }
  }

  /**
   * Returns an independent deep copy of this Genome.
   */
  public Genome copy() throws CloneNotSupportedException {
    ObjectGenome copy;

    int i;

    copy = (ObjectGenome)(super.clone());
		copy.alleleValues = new AlleleValue[alleleValues.length];
    for (i = 0; i < alleleValues.length; i++) {
      copy.alleleValues[i] = alleleValues[i].copy();
    }
    return copy;
  }

  /**
   * Performs mutation on the genome by randomly testing each element in
   * alleleValues[i] for mutation using the mutationRate.  If a test for
   * mutation is successful, replaces the value at alleleValues[i] with a
   * new AlleleValue object generated by a call to alleleSets[i].getRandomValue()
   */
  public void mutate () {
    int i;

    for (i = 0; i < alleleValues.length; i++) {
      if (uniform.nextDoubleFromTo(0, 1) < mutationRate) {
        alleleValues[i] = alleleSets[i].getRandomValue();
      }
    }
  }

  /**
   * Performs n point crossover using this genome and the dad Genome passed.
   * Returns an array of children (numChildren) create by crossover.
   */
  public Genome[] crossWith (Genome dad) {
    AlleleValue[] dadValues;      // allele values for the dad genome.
    AlleleValue[] momValues;      // allele values for the mom genome (this).
    AlleleValue[] currentValues;  // The values being copied (momValues or
                                  //   dadValues)
    ObjectGenome child = null;    // A child to produce
    ObjectGenome mommy, daddy;  // Variables used to cast mom and dad to
                                //   ObjectGenome
    Vector crossPointsVector;   // A vector randomly generated
                                //   crossover points
    int nextCrossPoint;         // The next crossover point
    Genome[] returnValue;       // The array of children to return
    int i,j,k;

    mommy = (ObjectGenome)this;
    daddy = (ObjectGenome)dad;
    dadValues = daddy.getAlleleValues();
    momValues = alleleValues;

    returnValue = new Genome[numChildren];

    for (i = 0; i < numChildren; i++) {
      // create the child
      try {
        child = (ObjectGenome)this.copy();
      }
      catch (CloneNotSupportedException e) {
        System.out.print("Clone not supported exception: " + e.getMessage());
        System.exit(1);
      }
      child.setIsEvaluated(false);

      // generate the crossover points
      crossPointsVector = new Vector(crossoverPoints);
      for (j = 0; j < crossoverPoints; j++) {
        crossPointsVector.add(j, new Integer(uniform.nextIntFromTo(0,
          alleleValues.length - 1)));
      }
      Collections.sort(crossPointsVector);  // sort the crossover points

      currentValues = momValues; // start by copying the momValues
      j = 0;                     // j is the index of crossover points
      nextCrossPoint = ((Integer)(crossPointsVector.get(j))).intValue();
      for (k = 0; k < alleleValues.length; k++) {  // for each alleleValue
				// if we have reached the next crossover pt (if it exists)
        while (k >= nextCrossPoint && j < crossoverPoints) {
          // swith momValues and dadValues
          if (currentValues == momValues) {
            currentValues = dadValues;
          }
          else {
            currentValues = momValues;
          }
          j++;  // increment the crossover point
					if (j < crossoverPoints) {
            nextCrossPoint = ((Integer)(crossPointsVector.get(j))).intValue();
					}
        }
        child.alleleValues[k] = currentValues[k].copy();
      }
      returnValue[i] = child;
    }
    return returnValue;
  }

  /**
   * Returns a string description of this object's parameters
   */
  public String describeParameters() {
    String description;
    int i;

    description = super.describeParameters();
    description += "crossoverPoints: " + crossoverPoints + "\n";

    for(i = 0; i < alleleValues.length; i++) {
      description += alleleValues[i].display() + " ";
    }
    description += "\n";

    return description;

  }

}
